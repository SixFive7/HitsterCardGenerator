---
phase: 26-unified-rendering
plan: 01
type: execute
---

<objective>
Add API endpoints for server-side card preview image generation using QuestPDF.

Purpose: Enable pixel-perfect card previews by using the same QuestPDF rendering for both preview and PDF export.
Output: Two new API endpoints (`/api/card-preview/front`, `/api/card-preview/back`) that return PNG images with in-memory caching.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-unified-rendering/26-CONTEXT.md
@.planning/phases/26-unified-rendering/26-RESEARCH.md

**Prior decisions affecting this phase:**
- QuestPDF is already used for PDF export (Phase 4, 9)
- CardDesigner.cs already has `GenerateFrontCardImage()` and `GenerateBackCardImage()` methods
- Minimal API pattern established for all endpoints in Endpoints/ folder

**Relevant source files:**
@Services/CardDesigner.cs
@Services/QrCodeService.cs
@Endpoints/ExportEndpoints.cs
@Program.cs
@Models/CardData.cs

**Implementation notes from research:**
- QuestPDF `GenerateImages()` returns PNG byte arrays at 288 DPI by default
- Single card generation is ~1-5ms (very fast)
- In-memory caching should use hash-based keys: `{trackId}_{side}_{backgroundColor}`
- Cache invalidation on color change (key includes color)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CardPreviewEndpoints with image generation</name>
  <files>Endpoints/CardPreviewEndpoints.cs, Program.cs</files>
  <action>
Create a new `CardPreviewEndpoints.cs` file in the Endpoints folder with:

1. A static class `CardPreviewEndpoints` following the existing endpoint pattern
2. Two POST endpoints:
   - `POST /api/card-preview/front` - Returns front card PNG (QR code)
   - `POST /api/card-preview/back` - Returns back card PNG (year, artist, title, genre)
3. Request model `CardPreviewRequest`:
   - `TrackId` (string) - Spotify track ID for QR code generation
   - `Title`, `Artist`, `Year`, `Genre` (string/int) - Card text content
   - `BackgroundColor` (string) - Hex color for background

Implementation:
- Use QrCodeService.GenerateQrCode(trackId) for front card
- Use CardDesigner.GenerateFrontCardImage/GenerateBackCardImage
- Return `Results.File(bytes, "image/png")` with appropriate cache headers
- Add `Cache-Control: public, max-age=3600` header for browser caching

Register the endpoints in Program.cs by adding `app.MapCardPreviewEndpoints();`
  </action>
  <verify>
Build succeeds: `dotnet build`
Endpoints are registered: Check OpenAPI docs at /openapi/v1.json
  </verify>
  <done>
- CardPreviewEndpoints.cs exists with two POST endpoints
- Program.cs includes MapCardPreviewEndpoints() call
- Build succeeds with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add in-memory caching layer for generated images</name>
  <files>Services/CardPreviewCache.cs, Endpoints/CardPreviewEndpoints.cs, Program.cs</files>
  <action>
Create a new `CardPreviewCache.cs` service for caching generated images:

1. Create `CardPreviewCache` class with:
   - `IMemoryCache` dependency (built-in .NET caching)
   - `GetOrCreateAsync(string cacheKey, Func<byte[]> generator)` method
   - Cache key format: `card_{trackId}_{side}_{backgroundColor}`
   - Cache expiration: 10 minutes sliding, 1 hour absolute

2. Update CardPreviewEndpoints to use the cache:
   - Inject `CardPreviewCache` via DI
   - Generate cache key from request parameters
   - Call cache.GetOrCreateAsync() instead of direct generation

3. Update Program.cs:
   - Add `builder.Services.AddMemoryCache()`
   - Add `builder.Services.AddSingleton<CardPreviewCache>()`

This ensures:
- Repeated requests for same card return cached PNG instantly
- Color changes generate new cached entry (color in key)
- Memory is managed by .NET's cache eviction policies
  </action>
  <verify>
Build succeeds: `dotnet build`
Test caching by making same request twice - second should be faster
  </verify>
  <done>
- CardPreviewCache.cs service exists with GetOrCreateAsync method
- CardPreviewEndpoints uses cache for all image generation
- Program.cs registers IMemoryCache and CardPreviewCache
- Build succeeds with no errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Test endpoints with curl and verify image output</name>
  <files>None (testing only)</files>
  <action>
Start the application and test both endpoints:

1. Start the server: `dotnet run`

2. Test front card endpoint:
```bash
curl -X POST http://localhost:5657/api/card-preview/front \
  -H "Content-Type: application/json" \
  -d '{"trackId":"4iV5W9uYEdYUVa79Axb7Rh","title":"Test","artist":"Test","year":2020,"genre":"Pop","backgroundColor":"#FF6B6B"}' \
  --output test-front.png
```

3. Test back card endpoint:
```bash
curl -X POST http://localhost:5657/api/card-preview/back \
  -H "Content-Type: application/json" \
  -d '{"trackId":"4iV5W9uYEdYUVa79Axb7Rh","title":"Blinding Lights","artist":"The Weeknd","year":2020,"genre":"Pop","backgroundColor":"#FF6B6B"}' \
  --output test-back.png
```

4. Verify PNG files are valid images (not empty, correct dimensions ~85x55mm at 288 DPI = ~960x620 pixels)

5. Clean up test files
  </action>
  <verify>
Both PNG files generated successfully
File sizes are reasonable (15-50KB each)
Images open correctly and show expected content
  </verify>
  <done>
- Front card endpoint returns valid PNG with QR code
- Back card endpoint returns valid PNG with year, artist, title, genre
- Response includes Cache-Control header
- Both endpoints work with different background colors
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `dotnet build` succeeds without errors
- [ ] CardPreviewEndpoints.cs exists with front and back endpoints
- [ ] CardPreviewCache.cs exists with caching logic
- [ ] Program.cs registers cache and endpoints
- [ ] Both endpoints return valid PNG images
- [ ] Cache-Control header is present in responses
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No build errors or warnings
- Endpoints return pixel-perfect QuestPDF-rendered card images
- Caching prevents redundant image generation
</success_criteria>

<output>
After completion, create `.planning/phases/26-unified-rendering/26-01-SUMMARY.md`
</output>
