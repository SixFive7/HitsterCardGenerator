# Plan 33-01: Playlist CRUD API

---
phase: 33-playlist-crud-api
type: execute
---

## Objective

Create RESTful API endpoints for complete playlist management including CRUD operations for playlists and track management within playlists.

**Purpose:** Enable browsers to create, read, update, and delete playlists, plus add/remove tracks within playlists. Browser identity is handled via explicit `X-Browser-Id` header.

**Output:** PlaylistEndpoints.cs with full CRUD endpoints, DTO models for request/response, and proper HTTP status codes.

## Context

**Current State:**
- LiteDB database configured with Playlist and Track models (Phase 32)
- IPlaylistRepository and ITrackRepository with CRUD operations
- Minimal API endpoint pattern established in Endpoints/ folder
- No playlist API endpoints exist

**Target State:**
- Full CRUD endpoints for playlists (GET list, GET single, POST, PUT, DELETE)
- Track management endpoints (POST add track, DELETE remove track)
- Browser ID validation via X-Browser-Id header
- Proper HTTP status codes (201 Created, 404 Not Found, etc.)

**Files to reference:**
- `Program.cs` - Endpoint registration pattern
- `Endpoints/SearchEndpoints.cs` - Endpoint implementation pattern
- `Repositories/IPlaylistRepository.cs` - Available repository methods
- `Repositories/ITrackRepository.cs` - Available repository methods
- `Models/Playlist.cs` - Playlist entity structure
- `Models/Track.cs` - Track entity structure

## Prerequisites

- Phase 32 (LiteDB Setup) complete
- Repositories registered in DI container

## Execution Tasks

### Task 1: Create DTO Models and Playlist CRUD Endpoints

**Files:**
- `Models/PlaylistDto.cs` (new)
- `Endpoints/PlaylistEndpoints.cs` (new)
- `Program.cs` (modify)

**Action:**

1. Create `Models/PlaylistDto.cs` with request/response DTOs:
```csharp
namespace HitsterCardGenerator.Models;

/// <summary>
/// Request to create a new playlist
/// </summary>
public record CreatePlaylistRequest(string Name);

/// <summary>
/// Request to update a playlist
/// </summary>
public record UpdatePlaylistRequest(string Name);

/// <summary>
/// Summary of a playlist for list views
/// </summary>
public record PlaylistSummary(
    string Id,
    string Name,
    int TrackCount,
    DateTime CreatedAt,
    DateTime UpdatedAt
);

/// <summary>
/// Detailed playlist with tracks
/// </summary>
public record PlaylistDetail(
    string Id,
    string Name,
    List<TrackDto> Tracks,
    DateTime CreatedAt,
    DateTime UpdatedAt
);

/// <summary>
/// Track data for API responses
/// </summary>
public record TrackDto(
    string Id,
    string SpotifyId,
    string Title,
    string Artist,
    int Year,
    string Genre,
    string? AlbumArtUrl
);

/// <summary>
/// Request to add a track to a playlist
/// </summary>
public record AddTrackRequest(
    string SpotifyId,
    string Title,
    string Artist,
    int Year,
    string Genre,
    string? AlbumArtUrl
);

/// <summary>
/// Response when a track is added to a playlist
/// </summary>
public record AddTrackResponse(
    string Id,
    string PlaylistId,
    TrackDto Track
);
```

2. Create `Endpoints/PlaylistEndpoints.cs` with playlist CRUD operations:
```csharp
using HitsterCardGenerator.Models;
using HitsterCardGenerator.Repositories;
using LiteDB;

namespace HitsterCardGenerator.Endpoints;

/// <summary>
/// Playlist management endpoints
/// </summary>
public static class PlaylistEndpoints
{
    private const string BrowserIdHeader = "X-Browser-Id";

    public static void MapPlaylistEndpoints(this WebApplication app)
    {
        var group = app.MapGroup("/api/playlists");

        // GET /api/playlists - List all playlists for browser
        group.MapGet("/", (HttpContext context, IPlaylistRepository playlistRepo) =>
        {
            var browserId = GetBrowserId(context);
            if (browserId == null)
            {
                return Results.BadRequest(new { error = "X-Browser-Id header is required" });
            }

            var playlists = playlistRepo.GetByBrowserId(browserId)
                .Select(p => new PlaylistSummary(
                    p.Id.ToString(),
                    p.Name,
                    p.TrackIds.Count,
                    p.CreatedAt,
                    p.UpdatedAt
                ))
                .ToList();

            return Results.Ok(playlists);
        })
        .WithName("GetPlaylists");

        // GET /api/playlists/{id} - Get single playlist with tracks
        group.MapGet("/{id}", (string id, HttpContext context,
            IPlaylistRepository playlistRepo, ITrackRepository trackRepo) =>
        {
            var browserId = GetBrowserId(context);
            if (browserId == null)
            {
                return Results.BadRequest(new { error = "X-Browser-Id header is required" });
            }

            if (!ObjectId.TryParse(id, out var objectId))
            {
                return Results.NotFound(new { error = "Playlist not found" });
            }

            var playlist = playlistRepo.GetById(objectId);
            if (playlist == null || playlist.BrowserId != browserId)
            {
                return Results.NotFound(new { error = "Playlist not found" });
            }

            var tracks = trackRepo.GetByIds(playlist.TrackIds)
                .Select(t => new TrackDto(
                    t.Id.ToString(),
                    t.SpotifyId,
                    t.Title,
                    t.Artist,
                    t.Year,
                    t.Genre,
                    t.AlbumArtUrl
                ))
                .ToList();

            var detail = new PlaylistDetail(
                playlist.Id.ToString(),
                playlist.Name,
                tracks,
                playlist.CreatedAt,
                playlist.UpdatedAt
            );

            return Results.Ok(detail);
        })
        .WithName("GetPlaylist");

        // POST /api/playlists - Create new playlist
        group.MapPost("/", (CreatePlaylistRequest request, HttpContext context,
            IPlaylistRepository playlistRepo) =>
        {
            var browserId = GetBrowserId(context);
            if (browserId == null)
            {
                return Results.BadRequest(new { error = "X-Browser-Id header is required" });
            }

            if (string.IsNullOrWhiteSpace(request.Name))
            {
                return Results.BadRequest(new { error = "Name is required" });
            }

            var playlist = new Playlist
            {
                BrowserId = browserId,
                Name = request.Name.Trim()
            };

            var id = playlistRepo.Create(playlist);

            var summary = new PlaylistSummary(
                id.ToString(),
                playlist.Name,
                0,
                playlist.CreatedAt,
                playlist.UpdatedAt
            );

            return Results.Created($"/api/playlists/{id}", summary);
        })
        .WithName("CreatePlaylist");

        // PUT /api/playlists/{id} - Update playlist
        group.MapPut("/{id}", (string id, UpdatePlaylistRequest request, HttpContext context,
            IPlaylistRepository playlistRepo) =>
        {
            var browserId = GetBrowserId(context);
            if (browserId == null)
            {
                return Results.BadRequest(new { error = "X-Browser-Id header is required" });
            }

            if (!ObjectId.TryParse(id, out var objectId))
            {
                return Results.NotFound(new { error = "Playlist not found" });
            }

            var playlist = playlistRepo.GetById(objectId);
            if (playlist == null || playlist.BrowserId != browserId)
            {
                return Results.NotFound(new { error = "Playlist not found" });
            }

            if (string.IsNullOrWhiteSpace(request.Name))
            {
                return Results.BadRequest(new { error = "Name is required" });
            }

            playlist.Name = request.Name.Trim();
            playlistRepo.Update(playlist);

            var summary = new PlaylistSummary(
                playlist.Id.ToString(),
                playlist.Name,
                playlist.TrackIds.Count,
                playlist.CreatedAt,
                playlist.UpdatedAt
            );

            return Results.Ok(summary);
        })
        .WithName("UpdatePlaylist");

        // DELETE /api/playlists/{id} - Delete playlist
        group.MapDelete("/{id}", (string id, HttpContext context, IPlaylistRepository playlistRepo) =>
        {
            var browserId = GetBrowserId(context);
            if (browserId == null)
            {
                return Results.BadRequest(new { error = "X-Browser-Id header is required" });
            }

            if (!ObjectId.TryParse(id, out var objectId))
            {
                return Results.NotFound(new { error = "Playlist not found" });
            }

            var playlist = playlistRepo.GetById(objectId);
            if (playlist == null || playlist.BrowserId != browserId)
            {
                return Results.NotFound(new { error = "Playlist not found" });
            }

            playlistRepo.Delete(objectId);
            return Results.NoContent();
        })
        .WithName("DeletePlaylist");
    }

    private static string? GetBrowserId(HttpContext context)
    {
        if (context.Request.Headers.TryGetValue(BrowserIdHeader, out var values))
        {
            var browserId = values.FirstOrDefault();
            if (!string.IsNullOrWhiteSpace(browserId))
            {
                return browserId;
            }
        }
        return null;
    }
}
```

3. Update `Program.cs` to register playlist endpoints:
```csharp
// Add after existing endpoint mappings (e.g., after MapCardPreviewEndpoints)
app.MapPlaylistEndpoints();
```

**Verify:** `dotnet build` succeeds, test with curl:
- `curl -H "X-Browser-Id: test-123" http://localhost:5657/api/playlists`
- `curl -X POST -H "X-Browser-Id: test-123" -H "Content-Type: application/json" -d '{"name":"Test"}' http://localhost:5657/api/playlists`

**Done:** Playlist CRUD endpoints (GET list, GET single, POST, PUT, DELETE) implemented

---

### Task 2: Add Track Management Endpoints

**Files:**
- `Endpoints/PlaylistEndpoints.cs` (modify)

**Action:**

Add track management endpoints to the existing PlaylistEndpoints.cs:

1. Add POST endpoint for adding tracks:
```csharp
// POST /api/playlists/{id}/tracks - Add track to playlist
group.MapPost("/{id}/tracks", (string id, AddTrackRequest request, HttpContext context,
    IPlaylistRepository playlistRepo, ITrackRepository trackRepo) =>
{
    var browserId = GetBrowserId(context);
    if (browserId == null)
    {
        return Results.BadRequest(new { error = "X-Browser-Id header is required" });
    }

    if (!ObjectId.TryParse(id, out var playlistId))
    {
        return Results.NotFound(new { error = "Playlist not found" });
    }

    var playlist = playlistRepo.GetById(playlistId);
    if (playlist == null || playlist.BrowserId != browserId)
    {
        return Results.NotFound(new { error = "Playlist not found" });
    }

    // Validate required fields
    if (string.IsNullOrWhiteSpace(request.SpotifyId))
    {
        return Results.BadRequest(new { error = "SpotifyId is required" });
    }

    if (string.IsNullOrWhiteSpace(request.Title))
    {
        return Results.BadRequest(new { error = "Title is required" });
    }

    if (string.IsNullOrWhiteSpace(request.Artist))
    {
        return Results.BadRequest(new { error = "Artist is required" });
    }

    // Create or reuse existing track
    var track = new Track
    {
        SpotifyId = request.SpotifyId,
        Title = request.Title.Trim(),
        Artist = request.Artist.Trim(),
        Year = request.Year,
        Genre = request.Genre?.Trim() ?? string.Empty,
        AlbumArtUrl = request.AlbumArtUrl
    };

    var trackId = trackRepo.GetOrCreate(track);
    var savedTrack = trackRepo.GetById(trackId);

    // Add track to playlist if not already present
    if (!playlist.TrackIds.Contains(trackId))
    {
        playlist.TrackIds.Add(trackId);
        playlistRepo.Update(playlist);
    }

    var trackDto = new TrackDto(
        savedTrack!.Id.ToString(),
        savedTrack.SpotifyId,
        savedTrack.Title,
        savedTrack.Artist,
        savedTrack.Year,
        savedTrack.Genre,
        savedTrack.AlbumArtUrl
    );

    var response = new AddTrackResponse(
        trackId.ToString(),
        playlist.Id.ToString(),
        trackDto
    );

    return Results.Created($"/api/playlists/{id}/tracks/{trackId}", response);
})
.WithName("AddTrackToPlaylist");
```

2. Add DELETE endpoint for removing tracks:
```csharp
// DELETE /api/playlists/{id}/tracks/{trackId} - Remove track from playlist
group.MapDelete("/{id}/tracks/{trackId}", (string id, string trackId, HttpContext context,
    IPlaylistRepository playlistRepo) =>
{
    var browserId = GetBrowserId(context);
    if (browserId == null)
    {
        return Results.BadRequest(new { error = "X-Browser-Id header is required" });
    }

    if (!ObjectId.TryParse(id, out var playlistObjectId))
    {
        return Results.NotFound(new { error = "Playlist not found" });
    }

    if (!ObjectId.TryParse(trackId, out var trackObjectId))
    {
        return Results.NotFound(new { error = "Track not found" });
    }

    var playlist = playlistRepo.GetById(playlistObjectId);
    if (playlist == null || playlist.BrowserId != browserId)
    {
        return Results.NotFound(new { error = "Playlist not found" });
    }

    // Remove track from playlist
    if (playlist.TrackIds.Contains(trackObjectId))
    {
        playlist.TrackIds.Remove(trackObjectId);
        playlistRepo.Update(playlist);
    }

    return Results.NoContent();
})
.WithName("RemoveTrackFromPlaylist");
```

**Verify:** `dotnet build` succeeds, test with curl:
- Add track: `curl -X POST -H "X-Browser-Id: test-123" -H "Content-Type: application/json" -d '{"spotifyId":"abc","title":"Test","artist":"Artist","year":2024,"genre":"Rock"}' http://localhost:5657/api/playlists/{id}/tracks`
- Remove track: `curl -X DELETE -H "X-Browser-Id: test-123" http://localhost:5657/api/playlists/{id}/tracks/{trackId}`

**Done:** Track management endpoints (POST add, DELETE remove) implemented

---

### Task 3: End-to-End API Verification

**Action:**

Run the application and verify all endpoints work correctly:

1. Start the application:
```bash
cd /workspaces/HitsterCardGenerator
dotnet run
```

2. Test complete CRUD cycle with curl:
```bash
# Set browser ID for testing
BROWSER_ID="test-browser-$(date +%s)"

# List playlists (should be empty)
curl -s -H "X-Browser-Id: $BROWSER_ID" http://localhost:5657/api/playlists

# Create a playlist
PLAYLIST_RESPONSE=$(curl -s -X POST \
  -H "X-Browser-Id: $BROWSER_ID" \
  -H "Content-Type: application/json" \
  -d '{"name":"My Test Playlist"}' \
  http://localhost:5657/api/playlists)
echo $PLAYLIST_RESPONSE

# Extract playlist ID (requires jq or manual inspection)
# PLAYLIST_ID=...

# Get the playlist
curl -s -H "X-Browser-Id: $BROWSER_ID" http://localhost:5657/api/playlists/{PLAYLIST_ID}

# Update the playlist
curl -s -X PUT \
  -H "X-Browser-Id: $BROWSER_ID" \
  -H "Content-Type: application/json" \
  -d '{"name":"Updated Playlist Name"}' \
  http://localhost:5657/api/playlists/{PLAYLIST_ID}

# Add a track
curl -s -X POST \
  -H "X-Browser-Id: $BROWSER_ID" \
  -H "Content-Type: application/json" \
  -d '{"spotifyId":"spotify123","title":"Test Song","artist":"Test Artist","year":2024,"genre":"Rock","albumArtUrl":"https://example.com/art.jpg"}' \
  http://localhost:5657/api/playlists/{PLAYLIST_ID}/tracks

# Get playlist with tracks
curl -s -H "X-Browser-Id: $BROWSER_ID" http://localhost:5657/api/playlists/{PLAYLIST_ID}

# Remove track
curl -s -X DELETE -H "X-Browser-Id: $BROWSER_ID" http://localhost:5657/api/playlists/{PLAYLIST_ID}/tracks/{TRACK_ID}

# Delete playlist
curl -s -X DELETE -H "X-Browser-Id: $BROWSER_ID" http://localhost:5657/api/playlists/{PLAYLIST_ID}
```

3. Verify error handling:
- Missing X-Browser-Id returns 400 Bad Request
- Invalid playlist ID returns 404 Not Found
- Accessing another browser's playlist returns 404 (security)
- Empty name returns 400 Bad Request

**Verify:**
- All endpoints return expected HTTP status codes
- Browser isolation works (can't access other browsers' playlists)
- Track deduplication works (same SpotifyId reuses track)
- Database persists data across restarts

**Done:** All API endpoints verified working correctly

---

## Verification

Before declaring phase complete:
- [ ] `dotnet build` succeeds without errors
- [ ] GET /api/playlists returns list of playlists for browser
- [ ] GET /api/playlists/{id} returns playlist with tracks
- [ ] POST /api/playlists creates new playlist (returns 201)
- [ ] PUT /api/playlists/{id} updates playlist name
- [ ] DELETE /api/playlists/{id} removes playlist (returns 204)
- [ ] POST /api/playlists/{id}/tracks adds track to playlist (returns 201)
- [ ] DELETE /api/playlists/{id}/tracks/{trackId} removes track (returns 204)
- [ ] Missing X-Browser-Id returns 400 Bad Request
- [ ] Invalid IDs return 404 Not Found
- [ ] Browser isolation enforced (can't access other browsers' playlists)

## Success Criteria

1. PlaylistDto.cs created with all request/response DTOs
2. PlaylistEndpoints.cs with full CRUD operations
3. Track management endpoints (add/remove)
4. X-Browser-Id header validation on all endpoints
5. Proper HTTP status codes (201, 204, 400, 404)
6. Browser isolation (users can only access their own playlists)
7. Track deduplication via GetOrCreate

## Technical Notes

**Browser ID Validation:**
The X-Browser-Id header is validated at the start of each endpoint. This explicit approach is simpler than middleware and keeps the logic visible.

**ObjectId String Conversion:**
LiteDB ObjectId is serialized to/from string for JSON transport. The `ObjectId.TryParse()` method handles invalid IDs gracefully.

**Track Deduplication:**
When adding tracks, we use `trackRepo.GetOrCreate()` to reuse existing tracks with the same SpotifyId. This saves database space and enables future analytics.

**Security Model:**
Playlist access is scoped to browser ID. When fetching a playlist, we verify both existence AND ownership before returning data. This prevents enumeration attacks.

## Output

After completion, create `.planning/phases/33-playlist-crud-api/33-01-SUMMARY.md`:

```markdown
# Phase 33: Playlist CRUD API Summary

**[One-liner describing what was accomplished]**

## Accomplishments

- [ ] Item 1
- [ ] Item 2

## Files Created/Modified

- `Models/PlaylistDto.cs` - Request/response DTO models
- `Endpoints/PlaylistEndpoints.cs` - All playlist API endpoints
- `Program.cs` - Registered playlist endpoints

## Decisions Made

| Decision | Rationale |
|----------|-----------|
| ... | ... |

## Issues Encountered

None / List any issues

## Next Phase Readiness

Ready for Phase 34: Playlist Selection UI
```
