# Plan 32-01: LiteDB Setup

---
phase: 32-litedb-setup
type: execute
---

## Objective

Add LiteDB as the embedded NoSQL database and create the data layer foundation with repository pattern for playlist management.

**Purpose:** Establish server-side persistence layer that will store playlists and tracks, enabling multi-playlist management with browser identity association (browser UUID comes in Phase 34).

**Output:** LiteDB package installed, data models created, ILiteDbContext wrapper with DI registration, and repository interfaces/implementations for Playlist and Track entities.

## Context

**Current State:**
- .NET 10 Minimal API backend with singleton services
- Song model exists for CSV/playlist data (not persisted)
- Memory cache used for card preview images
- No database or persistence layer

**Target State:**
- LiteDB 5.x installed and configured
- Playlist and Track models with ObjectId primary keys
- Singleton LiteDbContext wrapper with IDisposable
- IPlaylistRepository and ITrackRepository with CRUD operations
- Connection string configurable via appsettings.json

**Files to reference:**
- `Program.cs` - Service registration pattern
- `Models/Song.cs` - Existing song model (Track extends this concept)
- `Services/CardPreviewCache.cs` - Singleton service pattern

## Prerequisites

- Phase 31 (SkiaSharp Rendering) complete
- No database files exist yet

## Execution Tasks

### Task 1: Add LiteDB Package and Create Data Models

**Files:**
- `HitsterCardGenerator.csproj` (modify)
- `Models/Playlist.cs` (new)
- `Models/Track.cs` (new)

**Action:**

1. Add LiteDB NuGet package to project:
```xml
<PackageReference Include="LiteDB" Version="5.0.21" />
```

2. Create `Models/Playlist.cs`:
```csharp
namespace HitsterCardGenerator.Models;

using LiteDB;

public class Playlist
{
    public ObjectId Id { get; set; } = ObjectId.NewObjectId();
    public string BrowserId { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public List<ObjectId> TrackIds { get; set; } = new();
}
```

3. Create `Models/Track.cs`:
```csharp
namespace HitsterCardGenerator.Models;

using LiteDB;

public class Track
{
    public ObjectId Id { get; set; } = ObjectId.NewObjectId();
    public string SpotifyId { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public string Artist { get; set; } = string.Empty;
    public int Year { get; set; }
    public string Genre { get; set; } = string.Empty;
    public string? AlbumArtUrl { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
```

**Verify:** `dotnet restore && dotnet build` succeeds

**Done:** LiteDB package installed, Playlist and Track models created

---

### Task 2: Create LiteDbContext with DI Registration

**Files:**
- `Data/ILiteDbContext.cs` (new)
- `Data/LiteDbContext.cs` (new)
- `Data/LiteDbOptions.cs` (new)
- `appsettings.json` (modify)
- `Program.cs` (modify)

**Action:**

1. Create `Data/LiteDbOptions.cs`:
```csharp
namespace HitsterCardGenerator.Data;

public class LiteDbOptions
{
    public string ConnectionString { get; set; } = "Filename=./data/hitster.db;Connection=direct";
}
```

2. Create `Data/ILiteDbContext.cs`:
```csharp
namespace HitsterCardGenerator.Data;

using LiteDB;

public interface ILiteDbContext
{
    LiteDatabase Database { get; }
}
```

3. Create `Data/LiteDbContext.cs`:
```csharp
namespace HitsterCardGenerator.Data;

using LiteDB;
using Microsoft.Extensions.Options;

public class LiteDbContext : ILiteDbContext, IDisposable
{
    public LiteDatabase Database { get; }
    private bool _disposed;

    public LiteDbContext(IOptions<LiteDbOptions> options)
    {
        var connectionString = options.Value.ConnectionString;

        // Extract filename and ensure directory exists
        var filename = ExtractFilename(connectionString);
        var directory = Path.GetDirectoryName(filename);

        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        Database = new LiteDatabase(connectionString);
    }

    private static string ExtractFilename(string connectionString)
    {
        // Handle both "path.db" and "Filename=path.db;..." formats
        if (!connectionString.Contains('='))
            return connectionString;

        var parts = connectionString.Split(';');
        var filenamePart = parts.FirstOrDefault(p =>
            p.TrimStart().StartsWith("Filename=", StringComparison.OrdinalIgnoreCase));
        return filenamePart?.Split('=', 2)[1].Trim() ?? connectionString;
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            Database?.Dispose();
            _disposed = true;
        }
    }
}
```

4. Add to `appsettings.json`:
```json
{
  "LiteDbOptions": {
    "ConnectionString": "Filename=./data/hitster.db;Connection=direct"
  }
}
```

5. Update `Program.cs` to register LiteDB services:
```csharp
// Add after existing usings
using HitsterCardGenerator.Data;

// Add after existing service registrations (before AddMemoryCache)
builder.Services.Configure<LiteDbOptions>(
    builder.Configuration.GetSection("LiteDbOptions"));
builder.Services.AddSingleton<ILiteDbContext, LiteDbContext>();
```

**Verify:** `dotnet build` succeeds, application starts without errors

**Done:** LiteDbContext registered as singleton, creates data directory on startup

---

### Task 3: Create Repository Interfaces and Implementations

**Files:**
- `Repositories/IPlaylistRepository.cs` (new)
- `Repositories/PlaylistRepository.cs` (new)
- `Repositories/ITrackRepository.cs` (new)
- `Repositories/TrackRepository.cs` (new)
- `Program.cs` (modify)

**Action:**

1. Create `Repositories/IPlaylistRepository.cs`:
```csharp
namespace HitsterCardGenerator.Repositories;

using HitsterCardGenerator.Models;
using LiteDB;

public interface IPlaylistRepository
{
    Playlist? GetById(ObjectId id);
    IEnumerable<Playlist> GetByBrowserId(string browserId);
    ObjectId Create(Playlist playlist);
    bool Update(Playlist playlist);
    bool Delete(ObjectId id);
}
```

2. Create `Repositories/PlaylistRepository.cs`:
```csharp
namespace HitsterCardGenerator.Repositories;

using HitsterCardGenerator.Data;
using HitsterCardGenerator.Models;
using LiteDB;

public class PlaylistRepository : IPlaylistRepository
{
    private readonly ILiteDbContext _context;

    public PlaylistRepository(ILiteDbContext context)
    {
        _context = context;
    }

    private ILiteCollection<Playlist> Collection =>
        _context.Database.GetCollection<Playlist>("playlists");

    public Playlist? GetById(ObjectId id)
    {
        return Collection.FindById(id);
    }

    public IEnumerable<Playlist> GetByBrowserId(string browserId)
    {
        return Collection.Find(p => p.BrowserId == browserId);
    }

    public ObjectId Create(Playlist playlist)
    {
        playlist.CreatedAt = DateTime.UtcNow;
        playlist.UpdatedAt = DateTime.UtcNow;
        Collection.Insert(playlist);
        return playlist.Id;
    }

    public bool Update(Playlist playlist)
    {
        playlist.UpdatedAt = DateTime.UtcNow;
        return Collection.Update(playlist);
    }

    public bool Delete(ObjectId id)
    {
        return Collection.Delete(id);
    }
}
```

3. Create `Repositories/ITrackRepository.cs`:
```csharp
namespace HitsterCardGenerator.Repositories;

using HitsterCardGenerator.Models;
using LiteDB;

public interface ITrackRepository
{
    Track? GetById(ObjectId id);
    Track? GetBySpotifyId(string spotifyId);
    IEnumerable<Track> GetByIds(IEnumerable<ObjectId> ids);
    ObjectId Create(Track track);
    ObjectId GetOrCreate(Track track);
    bool Delete(ObjectId id);
}
```

4. Create `Repositories/TrackRepository.cs`:
```csharp
namespace HitsterCardGenerator.Repositories;

using HitsterCardGenerator.Data;
using HitsterCardGenerator.Models;
using LiteDB;

public class TrackRepository : ITrackRepository
{
    private readonly ILiteDbContext _context;

    public TrackRepository(ILiteDbContext context)
    {
        _context = context;
    }

    private ILiteCollection<Track> Collection =>
        _context.Database.GetCollection<Track>("tracks");

    public Track? GetById(ObjectId id)
    {
        return Collection.FindById(id);
    }

    public Track? GetBySpotifyId(string spotifyId)
    {
        return Collection.FindOne(t => t.SpotifyId == spotifyId);
    }

    public IEnumerable<Track> GetByIds(IEnumerable<ObjectId> ids)
    {
        var idList = ids.ToList();
        return Collection.Find(t => idList.Contains(t.Id));
    }

    public ObjectId Create(Track track)
    {
        track.CreatedAt = DateTime.UtcNow;
        Collection.Insert(track);
        return track.Id;
    }

    public ObjectId GetOrCreate(Track track)
    {
        // Check if track with same SpotifyId exists
        var existing = GetBySpotifyId(track.SpotifyId);
        if (existing != null)
        {
            return existing.Id;
        }
        return Create(track);
    }

    public bool Delete(ObjectId id)
    {
        return Collection.Delete(id);
    }
}
```

5. Update `Program.cs` to register repositories:
```csharp
// Add after ILiteDbContext registration
using HitsterCardGenerator.Repositories;

builder.Services.AddSingleton<IPlaylistRepository, PlaylistRepository>();
builder.Services.AddSingleton<ITrackRepository, TrackRepository>();
```

**Verify:** `dotnet build` succeeds, all repositories compile

**Done:** Repository pattern implemented for Playlist and Track entities

---

## Verification

Before declaring phase complete:
- [ ] `dotnet build` succeeds without errors
- [ ] Application starts without errors (`dotnet run`)
- [ ] Data directory `./data/` is created on first run
- [ ] `hitster.db` file is created in data directory
- [ ] No runtime errors in console output
- [ ] All new files follow existing code patterns (namespaces, styling)

## Success Criteria

1. LiteDB 5.0.21 package installed
2. Playlist model with ObjectId, BrowserId, Name, timestamps, TrackIds
3. Track model with ObjectId, SpotifyId, Title, Artist, Year, Genre, AlbumArtUrl
4. ILiteDbContext wrapper registered as singleton
5. LiteDbContext creates data directory if missing
6. IPlaylistRepository with CRUD operations
7. ITrackRepository with CRUD + GetOrCreate (deduplication by SpotifyId)
8. Connection string configurable via appsettings.json

## Technical Notes

**Why Singleton Pattern:**
LiteDB is thread-safe internally and recommends single instance for web apps to avoid file locking conflicts.

**Why Manual ObjectId References:**
Using `List<ObjectId>` for TrackIds instead of `[BsonRef]` gives explicit control and avoids circular reference issues. Tracks can be shared across playlists.

**Why GetOrCreate for Tracks:**
When users add the same Spotify track to multiple playlists, we reuse the same Track document to save space and enable future features like "popular tracks" analytics.

**Directory Creation:**
LiteDB auto-creates the database file but NOT parent directories. The context handles this to avoid runtime errors.

## Output

After completion, create `.planning/phases/32-litedb-setup/32-01-SUMMARY.md`:

```markdown
# Phase 32: LiteDB Setup Summary

**[One-liner describing what was accomplished]**

## Accomplishments

- [ ] Item 1
- [ ] Item 2

## Files Created/Modified

- `HitsterCardGenerator.csproj` - Added LiteDB package
- `Models/Playlist.cs` - Playlist entity
- `Models/Track.cs` - Track entity
- `Data/LiteDbOptions.cs` - Configuration class
- `Data/ILiteDbContext.cs` - Interface for DI
- `Data/LiteDbContext.cs` - Singleton wrapper for LiteDatabase
- `Repositories/IPlaylistRepository.cs` - Interface
- `Repositories/PlaylistRepository.cs` - Implementation
- `Repositories/ITrackRepository.cs` - Interface
- `Repositories/TrackRepository.cs` - Implementation
- `appsettings.json` - Added LiteDbOptions section
- `Program.cs` - Registered services

## Decisions Made

| Decision | Rationale |
|----------|-----------|
| ... | ... |

## Issues Encountered

None / List any issues

## Next Phase Readiness

Ready for Phase 33: Playlist CRUD API
```
